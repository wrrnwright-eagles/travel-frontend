import {
  VChip
} from "./chunk-Z7QSMBBP.js";
import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-MKUZX26N.js";
import {
  VSelectionControl,
  makeSelectionControlProps
} from "./chunk-MIYEU5PC.js";
import "./chunk-OCK6NB5O.js";
import {
  VInput,
  makeVInputProps,
  useFocus,
  useForm
} from "./chunk-QSAADWOM.js";
import {
  VList,
  VListItem,
  makeItemsProps,
  useItems
} from "./chunk-PVUDZLDZ.js";
import "./chunk-XS3OFN5O.js";
import "./chunk-GRFYBORQ.js";
import "./chunk-A7NVO7SJ.js";
import "./chunk-POQ232PX.js";
import "./chunk-ZELRLZGB.js";
import {
  VIcon
} from "./chunk-WEI2JEPD.js";
import "./chunk-DPRWBQHI.js";
import "./chunk-FT4NSXU4.js";
import {
  VMenu
} from "./chunk-DL5WPKEB.js";
import "./chunk-QIWPZ4IM.js";
import "./chunk-4C6UU3VN.js";
import "./chunk-5NSAISPT.js";
import "./chunk-LH6XZFY7.js";
import "./chunk-W3AGEJDN.js";
import "./chunk-QK3DHD4B.js";
import {
  forwardRefs
} from "./chunk-ZQ3SWHUJ.js";
import "./chunk-OZYSCKEH.js";
import {
  VDialogTransition
} from "./chunk-YWEGZIP7.js";
import {
  VDefaultsProvider
} from "./chunk-VLQJE4OK.js";
import "./chunk-6T3CKJCS.js";
import {
  makeTransitionProps
} from "./chunk-5YRKAGDB.js";
import "./chunk-P6YQ45NW.js";
import {
  IconValue
} from "./chunk-OLIYCAJI.js";
import "./chunk-NV7VZKOW.js";
import "./chunk-QPPBQJYG.js";
import {
  useLocale
} from "./chunk-RX42BONG.js";
import {
  useProxiedModel
} from "./chunk-4N4BACFQ.js";
import "./chunk-Q3NJ42RV.js";
import "./chunk-GYBFKNC4.js";
import {
  deepEqual,
  filterInputAttrs,
  genericComponent,
  getUid,
  omit,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-LFGRXAFU.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  mergeProps,
  ref,
  shallowRef
} from "./chunk-X72XCBY2.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "/Applications/XAMPP/xamppfiles/htdocs/seprojects/travel-frontend/node_modules/vuetify/lib/components/VSelect/VSelect.css";

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
import "/Applications/XAMPP/xamppfiles/htdocs/seprojects/travel-frontend/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css";

// node_modules/vuetify/lib/components/VCheckbox/VCheckboxBtn.mjs
var makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "v-checkbox-btn");
var VCheckboxBtn = genericComponent()({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const model = useProxiedModel(props, "modelValue");
    function onChange(v) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    const falseIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.trueIcon;
    });
    useRender(() => createVNode(VSelectionControl, mergeProps(props, {
      "modelValue": model.value,
      "onUpdate:modelValue": [($event) => model.value = $event, onChange],
      "class": ["v-checkbox-btn", props.class],
      "style": props.style,
      "type": "checkbox",
      "falseIcon": falseIcon.value,
      "trueIcon": trueIcon.value,
      "aria-checked": props.indeterminate ? "mixed" : void 0
    }), slots));
    return {};
  }
});

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
var makeVCheckboxProps = propsFactory({
  ...makeVInputProps(),
  ...omit(makeVCheckboxBtnProps(), ["inline"])
}, "v-checkbox");
var VCheckbox = genericComponent()({
  name: "VCheckbox",
  inheritAttrs: false,
  props: makeVCheckboxProps(),
  emits: {
    "update:focused": (focused) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const uid = getUid();
    const id = computed(() => props.id || `checkbox-${uid}`);
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = VInput.filterProps(props);
      const [checkboxProps, _2] = VCheckboxBtn.filterProps(props);
      return createVNode(VInput, mergeProps({
        "class": ["v-checkbox", props.class]
      }, inputAttrs, inputProps, {
        "id": id.value,
        "focused": isFocused.value,
        "style": props.style
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly
          } = _ref2;
          return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs, {
            "onFocus": focus,
            "onBlur": blur
          }), slots);
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeItemsProps({
    itemChildren: false
  })
}, "select");
var makeVSelectProps = propsFactory({
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: {
      component: VDialogTransition
    }
  })
}, "v-select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: makeVSelectProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const vMenuRef = ref();
    const _menu = useProxiedModel(props, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        var _a;
        if (_menu.value && !v && ((_a = vMenuRef.value) == null ? void 0 : _a.Î¨openChildren))
          return;
        _menu.value = v;
      }
    });
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => props.valueComparator(item.value, v.value)) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const isFocused = shallowRef(false);
    let keyboardLookupPrefix = "";
    let keyboardLookupLastTime;
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return items.value.filter((item) => !selections.value.some((s) => s === item));
      }
      return items.value;
    });
    const listRef = ref();
    function onClear(e) {
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (props.hideNoData && !items.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      var _a, _b, _c, _d;
      if (props.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "ArrowDown") {
        (_a = listRef.value) == null ? void 0 : _a.focus("next");
      } else if (e.key === "ArrowUp") {
        (_b = listRef.value) == null ? void 0 : _b.focus("prev");
      } else if (e.key === "Home") {
        (_c = listRef.value) == null ? void 0 : _c.focus("first");
      } else if (e.key === "End") {
        (_d = listRef.value) == null ? void 0 : _d.focus("last");
      }
      const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
      function checkPrintable(e2) {
        const isPrintableChar = e2.key.length === 1;
        const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
        return isPrintableChar && noModifier;
      }
      if (props.multiple || !checkPrintable(e))
        return;
      const now = performance.now();
      if (now - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
        keyboardLookupPrefix = "";
      }
      keyboardLookupPrefix += e.key.toLowerCase();
      keyboardLookupLastTime = now;
      const item = items.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
      if (item !== void 0) {
        model.value = [item];
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => props.valueComparator(selection, item.value));
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      var _a;
      if (!((_a = listRef.value) == null ? void 0 : _a.$el.contains(e.relatedTarget))) {
        menu.value = false;
      }
    }
    function onAfterLeave() {
      var _a;
      if (isFocused.value) {
        (_a = vTextFieldRef.value) == null ? void 0 : _a.focus();
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots.prepend || slots.append || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const [textFieldProps] = VTextField.filterProps(props);
      const placeholder = isDirty || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "dirty": isDirty,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }, props.class],
        "style": props.style,
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "placeholder": placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-select__content",
          "eager": props.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props.transition,
          "onAfterLeave": onAfterLeave
        }, props.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onFocusin": onFocusin
          }, {
            default: () => {
              var _a, _b, _c;
              return [!displayItems.value.length && !props.hideNoData && (((_a = slots["no-data"]) == null ? void 0 : _a.call(slots)) ?? createVNode(VListItem, {
                "title": t(props.noDataText)
              }, null)), (_b = slots["prepend-item"]) == null ? void 0 : _b.call(slots), displayItems.value.map((item, index) => {
                var _a2;
                if (slots.item) {
                  return (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
                    item,
                    index,
                    props: mergeProps(item.props, {
                      onClick: () => select(item)
                    })
                  });
                }
                return createVNode(VListItem, mergeProps({
                  "key": index
                }, item.props, {
                  "onClick": () => select(item)
                }), {
                  prepend: (_ref2) => {
                    let {
                      isSelected
                    } = _ref2;
                    return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                      "modelValue": isSelected,
                      "ripple": false,
                      "tabindex": "-1"
                    }, null) : void 0, item.props.prependIcon && createVNode(VIcon, {
                      "icon": item.props.prependIcon
                    }, null)]);
                  }
                });
              }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
            }
          })]
        }), selections.value.map((item, index) => {
          var _a;
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": "v-select__selection"
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props.closableChips,
            "size": "small",
            "text": item.title
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => {
              var _a2;
              return [(_a2 = slots.chip) == null ? void 0 : _a2.call(slots, {
                item,
                index,
                props: slotProps
              })];
            }
          }) : ((_a = slots.selection) == null ? void 0 : _a.call(slots, {
            item,
            index
          })) ?? createVNode("span", {
            "class": "v-select__selection-text"
          }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])])]);
        })])
      });
    });
    return forwardRefs({
      isFocused,
      menu,
      select
    }, vTextFieldRef);
  }
});
export {
  VSelect
};
//# sourceMappingURL=vuetify_lib_components_VSelect_index__mjs.js.map
